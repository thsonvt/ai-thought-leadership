---
title: Teach Your AI to Think Like a Senior Engineer
author: Dan Shipper (Every)
author_id: dan-shipper-every
url: https://every.to/source-code/teach-your-ai-to-think-like-a-senior-engineer-789ba7ca-ca7c-45a1-91fa-4178f59f226f
published: '2026-01-29'
fetched: '2026-01-31'
topics:
- Engineering Efficiency
- Strategic Planning in Tech
- AI in Software Development
key_quotes:
- text: I’ve written about why having your AI coding assistant plan before it codes
    lets you ship faster than jumping straight to code.
  context: The importance of planning in AI-assisted coding for efficiency.
- text: Planning had saved me from wasting time building the wrong thing entirely.
  context: A personal anecdote highlighting the value of strategic planning in software
    development.
- text: It’s much faster for five agents to research in parallel than for a human
    to plan step by step.
  context: Advocating for the use of multiple AI agents for parallel research to speed
    up the planning process.
stance:
  Cora: positive
  Claude_Code: positive
  AppSignal: neutral
evolution_note: This article represents a deep dive into the author's practical strategies
  for integrating AI into the software development lifecycle, indicating a mature
  understanding of AI's role in enhancing engineering productivity.
tags:
- ai-planning
- software-development
- engineering-best-practices
- ai-research-agents
- productivity
---

# Teach Your AI to Think Like a Senior Engineer

**Author**: Dan Shipper (Every)  
**Published**: 2026-01-29  
**Source**: [https://every.to/source-code/teach-your-ai-to-think-like-a-senior-engineer-789ba7ca-ca7c-45a1-91fa-4178f59f226f](https://every.to/source-code/teach-your-ai-to-think-like-a-senior-engineer-789ba7ca-ca7c-45a1-91fa-4178f59f226f)

---

<table><tr><td><img alt="Source Code" src="https://d24ovhgu8s7341.cloudfront.net/uploads/publication/logo/99/small_Frame_9121.png" /></td><td></td><td><table><tr><td>by <a href="https://every.to/@kieran_1355">Kieran Klaassen</a></td></tr><tr><td>in <a href="https://every.to/source-code">Source Code</a></td></tr></table></td></tr></table><figure><img src="https://d24ovhgu8s7341.cloudfront.net/uploads/post/cover/3903/full_page_cover_Teach_Your_AI_to_Think_Like_a_Senior_Engineer(2).png" /><figcaption>Midjourney/Every illustration.</figcaption></figure><p><em>While we’re on our Think Week offsite this week, we’re resurfacing </em><strong><em><u><a href="https://cora.computer/" rel="noopener noreferrer" target="_blank">Cora</a></u></em></strong><em> general manager </em><strong><em><u><a href="https://every.to/@kieran_1355" rel="noopener noreferrer" target="_blank">Kieran Klaassen</a></u></em></strong><em>’s work on the theme of compound engineering. In this piece, he talks about how running multiple specialized research agents in parallel before writing any code helps prevent building the wrong solution entirely—all while the human contributes judgment and taste. Plus: Eight planning strategies organized by complexity level that make your AI progressively smarter.—<u><a href="https://every.to/on-every/kate-lee-joins-every-as-editor-in-chief" rel="noopener noreferrer" target="_blank">Kate Lee</a></u></em></p><p><em>Was this newsletter forwarded to you? <u><a href="https://every.to/account" rel="noopener noreferrer" target="_blank">Sign up</a></u> to get it in your inbox.</em></p><p></p><hr class="quill-line" /><p></p><p>I’ve written about why having your <u><a href="https://every.to/source-code/stop-coding-and-start-planning" rel="noopener noreferrer" target="_blank">AI coding assistant plan</a></u> before it codes lets you ship faster than jumping straight to code. It’s my method for making my AI smarter with every feature. </p><p>For example, when I needed to implement <strong><u><a href="https://cora.computer" rel="noopener noreferrer" target="_blank">Cora</a></u></strong>’s <u><a href="https://cora.computer/declare-email-bankruptcy?utm_source=every_banner" rel="noopener noreferrer" target="_blank">email bankruptcy feature</a></u>—clearing 53,000-email inboxes without deleting anything important—I didn’t start by coding. I created a research agent to plan instead.</p><p>I thought this would be an easy feature. Bulk archive 53,000 emails—how hard could it be? I asked the research agent to analyze our own bulk operation patterns, check API limits for mass actions, and propose three implementation approaches with tradeoffs. </p><p>Twenty minutes later, it came back with a reality check: Gmail rate limits would kill us at 2,000 emails, our system would timeout on long operations, and the user would have to wait too long for the result. I thought it would be a quick feature, but it turned into a three-day architectural challenge. Planning had saved me from wasting time building the wrong thing entirely. </p><p>You can avoid building the wrong thing, too. I’ll show you the concrete tactics that turn a planning philosophy into working systems, starting with how to run parallel research operations that teach your AI how you think. Look out for Github links throughout the article—I’ve added them so you can copy and adapt the exact agents and commands I use, rather than building everything from scratch.</p><h2><strong>The eight planning strategies</strong></h2><p>When you’re planning with AI, you’re running parallel research operations—each one a specialized agent gathering different kinds of knowledge. Then you work together: The agents bring findings, you make decisions, and together you combine and distill everything into one coherent plan.</p><p>It’s much faster for five agents to research in parallel than for a human to plan step by step. Your contribution to the process is taste, judgment, and context about what matters for your product and users. </p><p>I use eight research strategies, depending on the fidelity level, which refers to the degree of difficulty. Fidelity One is quick fixes like one-line changes, obvious bugs, and copy updates. Fidelity Two covers features spanning multiple files with clear scope but non-obvious implementation. Fidelity Three covers major features where you don’t even know what you’re building yet.</p><h3><strong>Strategy 1: Reproduce and document</strong></h3><p><strong>What it does:</strong> Attempts to reproduce bugs or issues before planning fixes</p><p><strong>When to use it:</strong> Fidelity One and Two, especially bug fixes</p><p><strong>The agent’s job:</strong> Create a step-by-step reproduction guide</p><p><strong>Prompt:</strong> “Reproduce this bug, don’t fix it, just gather all the logs and info you need.”</p><p>Right after the launch of <u><a href="https://cora.computer/" rel="noopener noreferrer" target="_blank">Cora</a></u>’s <u><a href="https://cora.computer/declare-email-bankruptcy?utm_source=every_banner" rel="noopener noreferrer" target="_blank">email bankruptcy feature</a></u>, 19 users were stuck. They’d clicked “archive everything,” but the job failed. Instead of guessing the reason for the problem, I told Claude Code: “Loop through the AppSignal logs and diagnose this.” (AppSignal logs are our error tracking system that records what goes wrong in production.)</p><p>Five minutes later, I had a reply: Rate limit errors were being swallowed in production. The job hit Gmail’s limit, failed silently, and never resumed. Users would click “archive everything,” see a loading spinner, and wait forever—because when one batch failed, the entire job stopped, but we never told the user. That reproduction showed we needed batch processing and job resumption, not just retries.</p><div class="quill-block-image" id="quill-block-image-1768931857536"><div><a href="https://d24ovhgu8s7341.cloudfront.net/uploads/editor/posts/3816/optimized_4338eb3b-9016-49af-9fa7-b3ae78b79c38.png" rel="noopener noreferrer" target="_blank"><img alt="The agent reproduced the bug, found the root cause in production logs (records of what's happening on the live site users interact with), and documented everything automatically. (All screenshots courtesy of the author.)" src="https://d24ovhgu8s7341.cloudfront.net/uploads/editor/posts/3816/optimized_4338eb3b-9016-49af-9fa7-b3ae78b79c38.png" /></a><figcaption class="quill-image-caption">The agent reproduced the bug, found the root cause in production logs (records of what's happening on the live site users interact with), and documented everything automatically. (All screenshots courtesy of the author.)</figcaption></div></div><p><br /></p><p><strong>How to make this compound: </strong>To make sure that this issue wouldn’t happen in the future, I updated my @kieran-rails-reviewer agent—one of the specialized reviewers that automatically checks plans and code as part of my compounding engineering flow. I added to its checklist: “For any background job that calls external APIs—does it handle rate limits? Does it retry? Does it leave users in partial states?” We forgot to retry once. The system won’t let us forget<strong> </strong>again.</p><h3><strong>Strategy 2: Ground in best practices</strong></h3><p><strong>What it does:</strong> <u><a href="https://github.com/EveryInc/every-marketplace/blob/main/plugins/compounding-engineering/agents/best-practices-researcher.md" rel="noopener noreferrer" target="_blank">Searches the web</a></u> for how others solved similar problems</p><p><strong>When to use it:</strong> All fidelities, especially unfamiliar patterns</p><p><strong>The agent’s job:</strong> Find and summarize relevant blog posts, documentation, and solutions</p><p><strong>Agent:</strong> “<u><a href="https://github.com/EveryInc/every-marketplace/blob/main/plugins/compounding-engineering/agents/best-practices-researcher.md" rel="noopener noreferrer" target="_blank">@agent-best-practices-researcher</a></u>”</p><p>This strategy works for anything where someone else has already solved your problem—things like technical architecture, copywriting patterns, pricing research, or upgrade paths.</p><p>When I needed to upgrade a gem—a <u><a href="https://github.com/EveryInc/every-marketplace/blob/main/plugins/compounding-engineering/agents/framework-docs-researcher.md" rel="noopener noreferrer" target="_blank">pre-built code library</a></u> I use—that was two versions behind, I had an agent search: “upgrade path from version X to Y,” “breaking changes between versions,” “common migration issues.” It found the official upgrade guide, plus three blog posts from engineers who’d done the same upgrade and hit edge cases. That research took three minutes and prevented hours of trial-and-error debugging.</p><p>I’ve also used this for non-technical decisions: “SaaS pricing tiers best practices” returned frameworks for structuring pricing plans. “Email drip campaign conversion copy” found proven email templates. “Background job retry strategies” surfaced patterns in how other companies solved that problem at scale.</p><div class="quill-block-image" id="quill-block-image-1768931857537"><div><a href="https://d24ovhgu8s7341.cloudfront.net/uploads/editor/posts/3816/optimized_3017fd5d-7cb2-40a8-96be-0627e7e1e8a6.png" rel="noopener noreferrer" target="_blank"><img alt="The best-practices agent found: the library's official documentation, changelogs (lists of what changed between versions), and upgrade guides showing how to move my code to the new version—all with source links automatically included." src="https://d24ovhgu8s7341.cloudfront.net/uploads/editor/posts/3816/optimized_3017fd5d-7cb2-40a8-96be-0627e7e1e8a6.png" /></a><figcaption class="quill-image-caption">The best-practices agent found: the library's official documentation, changelogs (lists of what changed between versions), and upgrade guides showing how to move my code to the new version—all with source links automatically included.</figcaption></div></div><p><br /></p><p><strong>How to make this compound: </strong>When the agent finds a particularly useful pattern, I have it automatically save the key findings to `docs/*.md` files in my project. For instance, I’ve saved “docs/pay-gem-upgrades.md” for migration patterns and “docs/pricing-research.md” for pricing insights. Next time a similar question comes up, the agent checks these documents first before searching the web. My knowledge base is constantly growing and improving.</p><h3><strong>Strategy 3: Ground in your codebase</strong></h3><p></p><hr class="quill-line" /><p></p><p><strong>Become a <a href="https://every.to/subscribe" rel="noopener noreferrer" target="_blank">paid subscriber to Every</a> to unlock this piece and learn about:</strong></p><ol><li><span class="ql-ui" contenteditable="false"></span>Stopping reinventing solutions your codebase already has</li><li><span class="ql-ui" contenteditable="false"></span>Turning git history into institutional memory that prevents repeated mistakes</li><li><span class="ql-ui" contenteditable="false"></span>And the 4 other programming planning strategies that teach your AI how you think</li></ol><div class="quill-button" id="quill-button-1761066861282"><a href="https://every.to/subscribe?source=post_button">Upgrade to paid</a></div><p><hr /></p><p><em><a href="https://every.to/source-code/teach-your-ai-to-think-like-a-senior-engineer-789ba7ca-ca7c-45a1-91fa-4178f59f226f">Click here</a> to read the full post</em></p><p>Want the full text of all articles in RSS? <a href="https://every.to/subscribe">Become a subscriber</a>, or <a href="https://every.to">learn more</a>.

---

## Key Takeaways

### Notable Quotes

> I’ve written about why having your AI coding assistant plan before it codes lets you ship faster than jumping straight to code.

*Context: The importance of planning in AI-assisted coding for efficiency.*

> Planning had saved me from wasting time building the wrong thing entirely.

*Context: A personal anecdote highlighting the value of strategic planning in software development.*

> It’s much faster for five agents to research in parallel than for a human to plan step by step.

*Context: Advocating for the use of multiple AI agents for parallel research to speed up the planning process.*

## Related Topics

- [[topics/engineering-efficiency]]
- [[topics/strategic-planning-in-tech]]
- [[topics/ai-in-software-development]]
